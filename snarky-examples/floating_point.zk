// This is an incomplete example of floating point arithmetic. If you want to
// know more about it, ask Mathijs.
module Float = {
  let base_precision = 16i; // or 8...

  // x / 2^k, x < 2^m, k <= m
  type t =
    { k : int
    , m : int
    , x : field
    };

  let take = 
    fun (n, xs) => {
      loop(fun (take, (n, xs)) => {
        if (n = 0i) {
          [] ;
        } else {
          switch(xs) {
            | [] => []
            | x :: xs' => x :: take(n-1i, xs')
          };
        };
      }, (n, xs));
    };

  let low_bits = fun (t) => {
    let bits = List.rev(List.take(base_precision, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  // TODO!
  let ( * ) = fun (t1, t2) => {
    if (t1.m + t2.m < Field.size_in_bits) {
      { k: t1.k + t2.k
      , m: t1.m + t2.m
      , x: Field.( * )( t1.x , t2.x ) };
    } else {
      /* We could reduce just one but for ease of implementation we
         just reduce both. */
      let x1_trunc = low_bits(t1);
      let x2_trunc = low_bits(t2);
      { x: Field.( * )(x1_trunc, x2_trunc)
      , m: base_precision + base_precision
      , k: t1
      };
    };
  };

  let two_to_the : int -> field = fun (n) => {
    Field.of_int(lsl(1, n));
  };

  let ( + ) = fun (t1, t2) => {
    0;
  };
};
